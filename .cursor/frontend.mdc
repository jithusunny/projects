---
description: 
globs: 
alwaysApply: false
---
# üìê Cursor Rules

## 1. Vision / Philosophy / Design Principles

- Minimal, powerful, and expressive 
- Declarative over imperative 
- Explicit > Implicit 
- Reuse everything, repeat nothing 
- Components must be composable, modular, and standalone 
- Structure must be clear to both humans and AI 
- Styling must be functional, not ornamental 
- The codebase must be visually and structurally harmonious 
- Working on this should feel fun, clean, and poetic‚Äînot chaotic 
- Accessibility is non-negotiable: semantic HTML, tabindex, keyboard nav, ARIA roles, etc.

---

## 2. Strategy

- Use Lit for all UI ‚Äî components and pages ‚Äî with Shadow DOM enabled 
- Style everything using CSS custom properties (tokens), defined in `/styles/tokens.css` 
- Use Shoelace for accessible interactive primitives (buttons, inputs, dialogs, etc.) 
- Use vanilla JS modules for all logic, data, and behavior 
- Each page is a Lit component responsible for its own layout, data fetching, and rendering 
- Design is open to future expansion (context, shared events, state) but does not use global state now

---

## 3. Architecture Rules

### ‚úÖ Do:
- Create a Lit component for any repeated or interactive UI unit 
- Fetch data in page components using `connectedCallback()` 
- Use `CustomEvent` for component-to-parent communication (`this.dispatchEvent(new CustomEvent(...))`) 
- Pass data to children via attributes or properties ‚Äî never via globals or DOM queries 
- Use `<slot>` for layout/content projection, and properties for behavioral/configurable data 
- Use semantic HTML (`<section>`, `<article>`, `<button>`) wherever applicable 
- Handle loading and error states explicitly in all data-driven components 
- Structure all UI code into small, purpose-specific files 
- Define navigation routes in a single `router.js` or equivalent ‚Äî no auto-routing by file structure 
- Write clear test selectors using `data-testid` for all testable DOM elements

### ‚ùå Don't:
- Use Tailwind, BEM, or global utility classes 
- Use global state, reactive libraries, or context sharing (yet) 
- Use class names for styling or state ‚Äî style via `:host`, props, and `::part()` only 
- Use global event listeners or imperative DOM manipulation 
- Use div soup or hardcoded markup repetition 
- Mix layout logic into JavaScript behavior files 
- Leave fetches unguarded ‚Äî always use `loading` and `error` guards in render()
- Create own component, when shoelace has it.

---

## 4. Toolset

| Tool         | Purpose                                      |
|--------------|----------------------------------------------|
|   lit        | Web components with scoped styling and Shadow DOM  
|   shoelace   | Accessible, ready-to-use UI elements  
|   css vars   | Design tokens for color, spacing, sizing, etc.  
|   vanilla js  | Modular logic and API communication  
|   vite       | Build system and dev server  
|   playwright  | End-to-end testing only  

---

## 5. Naming Conventions

| Type           | Convention        | Example                        |
|----------------|-------------------|--------------------------------|
| Components     | kebab-case        | `<project-card>`               |
| Properties     | camelCase         | `.projectTitle = "Alpha"`      |
| Events         | kebab-case (scoped)| `project:created`, `chat:send`|
| Files/Folders  | kebab-case        | `project-detail-page.js`       |
| Test Selectors | kebab-case with domain | `data-testid="task-status"` |

---

## 6. File Structure

```
/frontend
‚îú‚îÄ‚îÄ index.html               # Entry point
‚îú‚îÄ‚îÄ main.js                  # Router + component registration
‚îú‚îÄ‚îÄ /components              # All Lit components (project-card.js, chat-pane.js, etc.)
‚îú‚îÄ‚îÄ /pages                   # Route-level views (projects-page.js, tasks-page.js, etc.)
‚îú‚îÄ‚îÄ /services                # Data-fetching modules (project.js, task.js)
‚îú‚îÄ‚îÄ /styles
‚îÇ   ‚îî‚îÄ‚îÄ tokens.css           # CSS design tokens
‚îú‚îÄ‚îÄ /utils                   # JS utility functions (formatting, logic, etc.)
‚îú‚îÄ‚îÄ vite.config.js
‚îî‚îÄ‚îÄ /dist                    # Production output
```

---

## 7. Testing Rules

- Only use   Playwright   for real user-flow testing 
- Never test internal implementation details or logic 
- Always use `data-testid` attributes for selecting UI elements 
- Ensure tests cover:
  - Form submission
  - Modal interactions
  - Navigation toggles
  - Card/list rendering
- Test both keyboard accessibility and role-based visibility

---

## 8. State Management

- No global state or state libraries at this stage 
- All data is fetched and stored locally inside the page/component 
- Shared state, context, or cross-component communication is not active ‚Äî structure is ready for it (`/context` folder) 
- Communication within a page/component tree is done via `CustomEvent` 
- Cursor must not introduce reactive libraries or hidden shared stores

---

## 9. Component Guidelines

- Every interactive or reusable visual unit must be a standalone Lit component 
- Use `static styles = css`` ` inside the component, scoped with Shadow DOM 
- Use CSS variables for any visual styling ‚Äî no hardcoded styles 
- Support customization via attributes or properties, not classnames 
- Inside Shoelace components, customize using `::part()` only 
- All behavior must be encapsulated inside the component or a related JS module ‚Äî never reach outside

---

## 10. Disallowed Tools & Patterns
We explicitly do not use or allow: React, Vue, Svelte, Angular, Tailwind, BEM, Handlebars, JSON schema-to-UI mappers, global state libraries (Redux, MobX, Zustand, etc.), or any abstraction that hides layout, logic, or markup clarity.

# 11. Routing
Only one page element lives inside <app-shell> at any moment.
Page JS is code-split: fetched only the first time it‚Äôs needed.
Navigation is instant after the first fetch because the element class is cached.
Lit handles the DOM diffing; you mostly change two fields (currentViewTag, params) and call requestUpdate()‚Äîthe rest is automatic.

# 12 Styling

- rem-First Only: use rem tokens everywhere; only px for 1px borders and fixed icons.

- Token-Exclusive: no literals‚Äîalways var(--‚Ä¶) for spacing, type, color, shadows, radii, borders, breakpoints, z-index, opacity, icon sizes.

- Global Container: wrap every <header>, <nav>, <main> (and page components) in .container { max-width: var(--container-max); margin: 0 auto; padding: var(--space-5) var(--space-4); }.

- Background Tone: body gets background: var(--grey-50) so white cards pop.

- Gap-Based Layout: always gap: var(--space-*) in flex/grid‚Äîno individual margins.

- Vertical Rhythm: sections and headings use consistent token margins (e.g. h2 { margin-bottom: var(--space-4); }, section { margin-top: var(--space-6); }).

- Semantic Typography: map <h1>‚Äì<h3>, <p>, <small> to --font-size-*, --line-height-*, --fw-* tokens via global base styles.

- Header Grid: inside <header>, use .container { display: grid; grid-template-columns: auto 1fr auto; align-items: center; gap: var(--space-4); } to centre the title.

- Card Consistency: all cards use <sl-card> (or .card) with box-shadow: var(--shadow-md), border: var(--border-1), border-radius: var(--radius-md), padding: var(--space-4).

- Section Separation: after every <h2> or <h3>, enforce margin-bottom: var(--space-5) to group content blocks.

- Hover & Focus: every clickable (cards, list items, links) has :hover { box-shadow: var(--shadow-lg) } and :focus { outline: 2px solid var(--color-primary); outline-offset: var(--space-1) }.

- Icons & Hit Areas: icons sized with --icon-*; all interactive elements get min-width/min-height: var(--space-5) for 44px+ touch targets.

- Responsive Breakpoints: use media queries at --breakpoint-sm/md/lg for grid-column counts, container padding, font adjustments.

- Shoelace Theming: override only via ::part() + tokens; never deep-select.

- Scoped Styles & API: every Lit component uses Shadow DOM + static styles; exposes slots, props, dispatches CustomEvents, and includes data-testid.

- Accessibility: semantic HTML, ARIA roles, proper tabindex on custom components.